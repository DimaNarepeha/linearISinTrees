\documentclass{article}
\usepackage{tikz}
\usepackage{bm}
\usepackage{listings}
\usepackage{amsfonts}
\usepackage{amsmath}

\lstset{
  language=Python,
  basicstyle=\ttfamily,
  keywordstyle=\color{blue},
  commentstyle=\color{green!40!black},
  stringstyle=\color{red},
  numbers=left,
  numberstyle=\tiny,
  stepnumber=1,
  numbersep=5pt,
  backgroundcolor=\color{gray!10},
  frame=single,
  rulecolor=\color{black!30},
  tabsize=2,
  captionpos=b,
  breaklines=true,
  breakatwhitespace=false
}
\begin{document}

\newcommand{\lettercircle}[1]{%
  \begin{tikzpicture}
    \node[circle, draw, minimum size=1cm] at (0,0) {#1};
  \end{tikzpicture}%
}


\section*{Problem Description: Counting Independent Sets in a Tree}
In this algorithm project, our primary objective is to develop an efficient algorithm that works in linear time to count independent sets within a tree structure. Independent sets, in the context of graph theory, refer to subsets of vertices in which no two vertices are adjacent. In our case, we focus on trees, which are a special type of graph with no cycles.

\subsection*{Solution Description:}
We utilized the depth fisrt search method. Traverse the nodes from the leaves to the root(bottom-up).
For each node, consider a subtree, whose root is that node, to get the IS of that subtree, denoted as $S$, we divide it two subsets $U$ and $C$: 
\begin{enumerate}
  \item IS without picking that node. denote as $U$ (unchosen), the count number of it, it's the cardinality of the set, denoted as $|U|$, the recursive procedure to get it is combinationsWithoutCurrent,  
  \item IS with the node, denote as $C$ (chosen), the count of it is $|C|$, the procedure is combinationWithCurrent . 
  \item the all IS,  denoted as $S$ , count number of all IS is $|S|$, the procedure is getAllSetsCount.
  Intuitively, the count number of the IS has formula as below:
    \[ |S| = |C| + |U| \] 
\end{enumerate}
We will calculate above three states for each node recursively, until we reach the root, the number of all IS count of the root,
$|S_{root}|$, is exactly the output expected. Pseudo code in python is as below: 
\newpage
\begin{lstlisting}
def combinationsWithoutCurrent(current):
    num = 1
    for child in current:
        num *= child.cachedWithoutValue + child.cachedWithValue
    return num


def combinationsWithCurrent(current):
    num = 1
    for child in current:
        num *= child.cachedWithoutValue
    return num


def getAllSetsCount(arrayOfNodes):
    for node in arrayOfNodes:
        with_current = combinationsWithCurrent(node)
        without_current = combinationsWithoutCurrent(node)
        node.cachedWithValue = with_current
        node.cachedWithoutValue = without_current
    # return root node calculated value [-1] is the last element which is root in this case
    return arrayOfNodes[-1].cachedWithValue + arrayOfNodes[-1].cachedWithoutValue
\end{lstlisting}

The tree and its node definitions are as below:

\begin{lstlisting}
class TreeNode:
    def __init__(self, data):
        self.data = data
        self.cachedWithValue = 0
        self.cachedWithoutValue = 0
        self.children = []

class Tree:
    def __init__(self, root_data):
        self.root = TreeNode(root_data)
\end{lstlisting}

Tree is nothing but a root tree node where we can end and all IS count of the tree is exactly $S_{root}$.

\subsection*{Proof of correctness and time complexity analysis}
We traverse the tree node exactly once, we denote the number of all nodes in the tree as N. So the time complexity of the algorithm with Big O notation is $O(N)$

Proof is as in the below, we define some notations: recall three states from the above, we denote sets $U_{L}$, $C_{L}$, $S_{L}$, as each set for the node L, we consider the bottom up recursion, using the induction method:
\begin{itemize}
  \item Base case: Consider the case, a leaf node, denoted as $L$, a leaf is a node who has no children, the IS of $L$ without picking it, is $\emptyset$, $|U_{L}=1|$  the IS of $L$ including it, is the node itself${L}$, $C_{L}=1$, all IS set count is: $|S_{L}| = |U_{L}| + |C_{L}| = 2$ 
  \item Inductive Hypothesis: Because we traverse from the bottom to the top, let's move one level up, consider the subtree starting from the parent of the node, let's denote the parent node as $P$. To calculate all IS Count of the subtree roots from $P$, let's divide into two cases: 
    \begin{enumerate}
      \item IS without P
      \item IS with P. 
    \end{enumerate}

    In case of 1, think about each child node, denoted as $D_{1...n}$ meaning Nth child node of the parent node P, from 1 to N, let's consider each Independent set of the substree roots from the child node, 
    \[ S_{D} =  U_{D} \cup C_{D} \]
    To get the $S_P$ we consider Cartesion product of each $S_{D_n}$, meaning:
    \[ S_P = \{ x \in \mathbb{R} \,|\, x^2 = 1 \} \]
    The number of combinations of choosing $k$ elements from a set of $n$ elements is denoted as $\binom{n}{k}$.
    the result is combinations of IS of each child. 
    
    $\prod_S(C)$. We denote $S(C)$ as the stable set of the node C, the below follows this convention.

    In case of 2, the result will be the combinations of IS of each child without the child node inside, $\prod_U(C)$. However when we were calculating the $S(C)$, recall, $S= C + U$, we got and memorized the result of $U$, so this step does not cost any computational complexity. 

    Above two cases are exactly what described in the pseudo code.
    The stable set of P is sum of two cases
  \item Inductive Step: We level up until reach the root. The stable set of the root is the result expected.
  \end{itemize}


\subsection*{Input and output}
Input: a text file, each line represents the tree in a string format, for example: 1 [2 [4, 5], 3 [6, 7]], representing a tree as below:


\begin{tikzpicture}
  \node {1}
    child[sibling distance=3cm]{
      node {2}
      child [sibling distance=1cm]{
        node {4}
      }
      child [sibling distance=1cm]{
        node {5}
      }
    }
    child [sibling distance=3cm]{
      node {3}
      child [sibling distance=1cm]{
        node {6}
      }
      child [sibling distance=1cm]{
        node {7}
      }
    };
\end{tikzpicture}

The expected output is 41, a number represents the count of the independent sets in the tree. 

Input file will be input.txt under the current directory while output file will be output.txt.

Each line of the input is a tree, the corresponding line in the output file will be IS count.


\end{document}



